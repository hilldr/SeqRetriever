
#' SeqANOVA
#'
#' This function performs Analysis of variance (ANOVA) on SeqDataframe() format dataframes and returns a P-value. Groups are selected automaticaly based on name e.g. group1_0, group1_1, group1_2, group2_0, group2_1, group2_2,group3_0, group3_1, group3_2 would perform ANOVA on group1, group2, and group3. Returns p-value (anova.p) and adjusted p-vale (anova.p.adj)
#' @param data The dataframe generated by SeqDataframe
#' @param p.adjust.method Correction method for ANOVA p-value. Acceepted options are "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none". See ?p.adjust for discussion of methods. Default = "bonferroni"
#' @return dataframe
#' @export
#' @examples
#' results <- SeqANOVA(SeqDataframe(dir="./norm_out"))
#' 
SeqANOVA <- function(df = df,
                     p.adjust.method = "bonferroni"){
    
    library(matrixStats)
    
    ## Get the unique group names
    group_names <- function(df){
        names <- unique(gsub("\\_[0-9]*$", "",colnames(df)[grep("gene|.p", colnames(df),invert = TRUE)]))
        return(names)
    }
    ## Get the total samples, N
    get_n <- function(df){
        n <- length(unique(colnames(df)[grep("gene|.p", colnames(df),invert = TRUE)]))
        return(n)
    }
    
    get_matrices <- function(df){

        get_groups <- function(df){		
            list <- lapply(group_names(df),
                           function(x) {grep(x, colnames(df))})
            list[[length(list)+1]] <- grep("gene|.p", colnames(df),invert = TRUE)
            return(list)
        }
        
        x <- get_groups(df)
        matrices <- sapply(x, function(x){df[,x]})
        return(matrices)
    }

    mats <- get_matrices(df)[-length(get_matrices(df))]
    ## parallel implementation
    ## library(parallel)
    ## c <- makePSOCKcluster(detectCores())
    ## sst.1 <- parLapply(cl = c,
    ##                    mats, function(mats){rowSums((mats), na.rm = TRUE)})
    ## stopCluster(c)
    sst.1 <- lapply(mats,
                    function(mats){rowSums((mats), na.rm = TRUE)})
    sst.2 <- lapply(mats,
                    function(mats){rowSums((mats^2), na.rm = TRUE)})
    
    sst.1 <- data.frame(matrix(unlist(sst.1),
                               nrow = unique(sapply(sst.1, length)),
                               byrow = FALSE))
    sst.2 <- data.frame(matrix(unlist(sst.2),
                               nrow = unique(sapply(sst.2, length)),
                               byrow = FALSE))
    
    get_sst <- function(sst.1,sst.2, df){
        sst <- rowSums(sst.2) - (rowSums(sst.1)^2)/get_n(df)
        return(sst)
    }
    
    sst <- get_sst(sst.1,sst.2, df)
    ssa <- rowSums((sst.1^2)/unlist(lapply(mats, function(x) length(x)))) -  (rowSums(sst.1)^2)/get_n(df)
    
    ssw <- sst - ssa

    fstat <- (ssa/(length(mats)-1))/(ssw/(get_n(df)-length(mats)))
    ## express f-statistic as p-value
    df$anova.p <- pf(q = fstat,
                     df1 = length(mats)-1,
                     df2 = (get_n(df)-length(mats)), lower.tail = FALSE)
    
    df$anova.p.adj <- p.adjust(df$anova.p,
                               method = p.adjust.method,
                               n = length(df$anova.p))
    return(df)
}
## Sources for ANOVA formula
## https://people.richland.edu/james/lecture/m170/ch13-1wy.html
## http://web.mst.edu/~psyworld/anovaexample.htm
